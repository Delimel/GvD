<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GIV DAO - Coming Soon</title>
    <meta
      name="description"
      content="Equitable Starts DAO‚ÄîFueling Humanity's Next Chapter"
    />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,700&display=swap");
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: "Playfair Display", serif;
        color: #f0f0f0;
      }
      canvas {
        display: block;
      }
      .thumbs {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        display: flex;
        gap: 20px;
      }
      .thumb-orb {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: radial-gradient(circle, #EDB333, #B8860B);
        border: 2px solid #00A3FF;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: #000;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 0 10px rgba(0, 163, 255, 0.3);
      }
      .thumb-orb:hover {
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(0, 163, 255, 0.6);
      }
      .thumb-orb.voted {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .count {
        position: absolute;
        bottom: -25px;
        left: 50%;
        transform: translateX(-50%);
        font-family: monospace;
        font-size: 12px;
        color: #F0F0F0;
        text-shadow: 1px 1px 2px #333;
      }
      .tooltip {
        position: absolute;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
      }
      .tooltip.show {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" role="img" alt="DAO Teaser Animation" tabindex="0"></canvas>
    <div id="text-overlay" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:clamp(2rem,6rem,6vw);color:#EDB333;font-style:italic;font-weight:700;opacity:0;z-index:5;pointer-events:none;">Coming Soon</div>
    <div class="thumbs">
      <div class="thumb-orb" id="up-orb" tabindex="0" aria-label="Vote up for GIV DAO">
        üëç
        <div class="count" id="up-count">0</div>
        <div class="tooltip">Voted‚ÄîShare on X? <a href="https://x.com/GivDAO" target="_blank">@GivDAO</a></div>
      </div>
      <div class="thumb-orb" id="down-orb" tabindex="0" aria-label="Vote down for GIV DAO">
        üëé
        <div class="count" id="down-count">0</div>
        <div class="tooltip">Voted‚ÄîShare on X? <a href="https://x.com/GivDAO" target="_blank">@GivDAO</a></div>
      </div>
    </div>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.169.0/build/three.module.js';
      import { gsap } from 'https://unpkg.com/gsap@3.12.2/index.js';
      import { createClient } from 'https://unpkg.com/@supabase/supabase-js@2/dist/module/index.js';

      window.THREE = THREE;
      window.gsap = gsap;
      window.supabase = { createClient };
    </script>
    <script>
      try {
        // Wait for modules to load
        setTimeout(() => {
          if (!window.THREE) throw new Error('THREE.js not loaded');
          initAnimation();
        }, 100);
      } catch (error) {
        console.error('Animation init failed:', error);
        document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-size:clamp(2rem,6rem,6vw);color:#EDB333;font-style:italic;font-weight:700;">Coming Soon</div>' + document.querySelector('.thumbs').outerHTML;
        // Load votes
        const supabaseUrl = 'https://your-project.supabase.co';
        const supabaseKey = 'your-anon-key';
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
        async function loadVotes() {
          const { data } = await supabase.from('votes').select('type, count').eq('dao', 'gvd');
          document.getElementById('up-count').textContent = data.find(d => d.type === 'up')?.count || 0;
          document.getElementById('down-count').textContent = data.find(d => d.type === 'down')?.count || 0;
        }
        loadVotes();
        return;
      }

      function initAnimation() {
      // Supabase setup (anon key needed)
      const supabaseUrl = 'https://your-project.supabase.co'; // Replace with actual
      const supabaseKey = 'your-anon-key'; // Replace with actual
      const supabase = supabase.createClient(supabaseUrl, supabaseKey);

      // Session check
      if (sessionStorage.getItem('viewed')) {
        // Skip animation, show static
        document.getElementById('text-overlay').style.opacity = '1';
        loadVotes();
        return;
      }
      sessionStorage.setItem('viewed', 'true');

      // Three.js Scene
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("canvas"),
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000);

      // Nebula particles with Perlin noise
      const particleCount = 300;
      const particleGeometry = new THREE.BufferGeometry();
      const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          uniform float time;
          attribute float size;
          attribute float alpha;
          varying float vAlpha;
          varying vec3 vPosition;

          // Perlin noise function
          vec3 mod289(vec3 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec4 mod289(vec4 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec4 permute(vec4 x) {
            return mod289(((x*34.0)+1.0)*x);
          }
          vec4 taylorInvSqrt(vec4 r) {
            return 1.79284291400159 - 0.85373472095314 * r;
          }
          float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
          }

          void main() {
            vPosition = position;
            vAlpha = alpha * (0.5 + 0.5 * snoise(position * 0.01 + time * 0.1));
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          void main() {
            gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
      });

      const positions = [];
      const sizes = [];
      const alphas = [];
      for (let i = 0; i < particleCount; i++) {
        positions.push((Math.random() - 0.5) * 200);
        positions.push((Math.random() - 0.5) * 200);
        positions.push((Math.random() - 0.5) * 200);
        sizes.push(Math.random() * 1.5 + 0.5);
        alphas.push(Math.random() * 0.4 + 0.1);
      }
      particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      particleGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
      particleGeometry.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));

      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      // Metaballs
      const metaballGeometry = new THREE.PlaneGeometry(20, 20, 64, 64);
      const metaballMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        },
        vertexShader: `
          void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec2 resolution;

          float metaball(vec2 p, vec2 center, float radius) {
            return radius / length(p - center);
          }

          void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy;
            uv = uv * 2.0 - 1.0;
            uv.x *= resolution.x / resolution.y;

            float m1 = metaball(uv, vec2(sin(time * 0.5) * 0.5, cos(time * 0.3) * 0.3), 0.3);
            float m2 = metaball(uv, vec2(-sin(time * 0.4) * 0.4, -cos(time * 0.6) * 0.2), 0.25);
            float m3 = metaball(uv, vec2(cos(time * 0.7) * 0.3, sin(time * 0.2) * 0.4), 0.2);

            float sum = m1 + m2 + m3;
            float color = smoothstep(0.8, 1.2, sum);

            gl_FragColor = vec4(vec3(color), color * 0.5);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
      });

      const metaballs = new THREE.Mesh(metaballGeometry, metaballMaterial);
      metaballs.position.z = -5;
      scene.add(metaballs);

      // Text
      const textGeometry = new THREE.PlaneGeometry(10, 2);
      const textMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          emissiveColor: { value: new THREE.Color(0xEDB333) },
          glowColor: { value: new THREE.Color(0x00A3FF) },
          opacity: { value: 0 },
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 emissiveColor;
          uniform vec3 glowColor;
          uniform float opacity;

          void main() {
            vec2 uv = vUv;
            // Simple text shape (placeholder for "Coming Soon")
            float text = step(0.1, uv.x) * step(uv.x, 0.9) * step(0.1, uv.y) * step(uv.y, 0.9);
            vec3 color = emissiveColor * text + glowColor * (1.0 - text) * 0.2;
            gl_FragColor = vec4(color, opacity * text);
          }
        `,
        transparent: true,
      });

      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      textMesh.position.set(0, 0, -10);
      scene.add(textMesh);

      camera.position.z = 10;

      // GSAP Timeline
      const tl = gsap.timeline();

      // 0-5s: Build void
      tl.set(renderer.domElement, { opacity: 0 })
        .to(renderer.domElement, { opacity: 1, duration: 1 }, 0)
        .set(particles.material.uniforms.time, { value: 0 }, 0)
        .to(particles.material.uniforms.time, { value: 5, duration: 5 }, 0);

      // 5-10s: Morph reveal
      tl.set(metaballs.material.uniforms.time, { value: 0 }, 5)
        .to(metaballs.material.uniforms.time, { value: 5, duration: 5 }, 5)
        .to('#text-overlay', { opacity: 1, duration: 2.5 }, 7.5);

      // 10-15s: Ebb
      tl.to(metaballs.scale, { x: 0, y: 0, z: 0, duration: 3 }, 10)
        .to('#text-overlay', { opacity: 0, duration: 3 }, 10)
        .to(particles.material.uniforms.alpha, { value: 0, duration: 3 }, 10);

      // Mouse parallax
      let mouseX = 0, mouseY = 0;
      document.addEventListener('mousemove', (e) => {
        mouseX = (e.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      // Animate
      function animate() {
        requestAnimationFrame(animate);
        particleMaterial.uniforms.time.value += 0.01;
        metaballMaterial.uniforms.time.value += 0.01;
        textMaterial.uniforms.time.value += 0.01;

        // Parallax
        camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
        camera.position.y += (mouseY * 5 - camera.position.y) * 0.05;

        renderer.render(scene, camera);
      }
      animate();

      // Thumbs
      async function loadVotes() {
        const { data } = await supabase.from('votes').select('type, count').eq('dao', 'gvd');
        // Assume data has up and down
        document.getElementById('up-count').textContent = data.find(d => d.type === 'up')?.count || 0;
        document.getElementById('down-count').textContent = data.find(d => d.type === 'down')?.count || 0;
      }
      loadVotes();

      function vote(type) {
        if (sessionStorage.getItem('voted')) return;
        supabase.rpc('increment_vote', { dao: 'gvd', type });
        sessionStorage.setItem('voted', 'true');
        document.getElementById(type + '-orb').classList.add('voted');
        document.querySelector(`#${type}-orb .tooltip`).classList.add('show');
        setTimeout(() => document.querySelector(`#${type}-orb .tooltip`).classList.remove('show'), 3000);
      }

      document.getElementById('up-orb').addEventListener('click', () => vote('up'));
      document.getElementById('down-orb').addEventListener('click', () => vote('down'));
      document.getElementById('up-orb').addEventListener('keydown', (e) => { if (e.key === 'Enter') vote('up'); });
      document.getElementById('down-orb').addEventListener('keydown', (e) => { if (e.key === 'Enter') vote('down'); });

      // Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        metaballMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      });
      }
    </script>
  </body>
</html>
